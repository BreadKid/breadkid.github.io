{"pages":[{"title":"About me","text":"About this siteBegining with wordpress based on AWS EC2Then migrate to gitpage and hexo, use ‘nexT’ theme Mainly in writing notes About meGet salary by JavaInterested in Respberry Pi, funny script, open source technology,Live in Shanghai About my Wechat subscription accountPush some notes and daily life story. If you have interests, thank you for your following.","link":"/about/me.html"},{"title":"吴先森的***恋爱通关***成就列表","text":"B with UI love all of u 2017.3.27 #达成相识成就# 2017.3.27 #达成送礼物🎁成就# 2017.4.19 #达成表白成就# 2017.4.22 #达成papapa❤️成就# 2017.4.27 #达成陪伴生日🎂成就# 2017.5.20 #达成共度520成就# 2017.5.30 #达成送粽子成就# 2017.6.1 #达成买衣服👔成就# 2017.6.3 #达成压马路3公里🚶‍♀️🚶成就# 2017.6.10 #达成安慰成就# 2017.6.11 #达成种草成就# 2017.7.28 #达成100天成就# 2017.8.12 #达成单手解锁👙成就# 2017.8.28 #达成七夕送花🌹成就# 2017.9.6 #达成送月饼🌛成就# 2017.9.8 #达成连续四天约会成就# 2017.9.16 #达成删除ex成就# 2017.9.16 #达成划船⛵️成就# 2017.10.6 #达成大扫除成就# 2017.10.8 #达成见闺蜜成就# 2017.10.14 #达成送蛋糕成就# 2017.10.14 #达成登高100楼成就# 2017.10.14 #达成吃大螃蟹🦀️成就# 2017.10.14 #达成送情书💌成就# 2017.10.22 #达成地方领导会晤成就# 2017.11.4 #达成烹饪美味番茄意面🍝成就# 2017.11.4 #达成太鼓达人咚咚咚成就# 2017.11.11 #达成制作失败辣肉面🍜成就# 2017.11.14 #达成鼓励工作成就# 2017.11.18 #达成家庭火锅🍲成就# 2017.11.25 #达成出席婚礼💒成就# 2017.11.30 #达成见宝宝家长成就，顺便获取了红包# 2017.12.2 #达成城隍庙汤包成就# 2017.12.8 #达成逛商场成就# 2017.12.9 #达成自制牛排&amp;罗宋汤成就# 2017.12.16 #达成毛脚女婿上门成就# 2018.1.21 #达成看望Bobbi🦔成就，并上门吃饭# 2018.2.08 #达成为了情人节请假成就# 2018.2.14 #达成共渡情人节成就# 2018.2.17 #达成宝宝春节上门成就# 2018.2.17 #达成大头贴成就# 2018.2.20 #达成我春节上门成就，顺便获取红包# 2018.3.10 #达成制作蛋饼🥞成就# 2018.3.31 #达成给Bobbi🦔洗澡成就# 2018.3.31 #达成逛古猗园成就# 2018.3.31 #达成吃小笼包成就# 2018.4.19 #达成一周年成就# 2018.4.27 #达成共渡吴先森30岁生日🎂成就# 2018.4.30 #达成给Bobbi🦔换新家成就# 2018.5.5 #达成送感冒药成就# 2018.5.5 #达成首次外出火锅🍲成就# 2018.5.5 #达成首次合唱🎤成就# 2018.7.14 #达成音乐厅彩虹合唱团成就# 2018.7.20 #达成获得美丽发夹成就# 2018.7.28 #达成吃哈根达斯🍦成就# 2018.7.28 #达成送草帽成就# 2018.8.5 #达成逛China Joy成就# 2018.8.5 #达成第一次丢失礼物成就# 2018.8.8 #达成位置共享甜蜜成就# 2018.8.11 #达成人肉快递爱心原味鸡成就# 2018.8.18 #达成补过七夕🎎成就# 2018.8.18 #达成送项链成就# 2018.8.18 #达成逛书展📖成就# 2018.9.1 #达成500天成就# 2018.9.8 #达成双方家长正式会晤成就# 2018.10.28 #达成装修新房🏠成就# 2018.11.11 #达成双十一大额买买买成就# 2018.11.24 #达成颜射成就# 2018.12.9 #达成冬日送书📖成就# 2018.12.22 #达成吃100样没有的必胜客🍕成就# 2018.12.30 #达成雪中❄️漫步成就# 2019.01.02 #达成下班地铁偶遇成就# 2019.01.26 #达成一起包喜糖成就# 2019.02.05 #达成一起拼乐高成就# 2019.02.14 #达成求婚💍成就# 2019.03.16 #达成婚礼💒成就# 2019.03.17 #达成回门🏠成就# 2019.03.23 #达成搬家成就# 2019.03.24 #达成Bobbi🦔搬家成就# 2019.09.09 #达成结婚成就#","link":"/coderwu/index.html"},{"title":"外公","text":"活到现在第一次身边有亲人去世，我的外公在2020年4月14日5点13分安详地走了。 望着我妈发来的消息老半天，酝酿出一滴泪，内心还是平静的。 小时候每周末都要和妈妈回娘家，我出生前外公就一个人了，每次去他家都会教我折纸，他会从床头柜拿出裁剪的四四方方的午餐肉罐头包装纸，教我折千纸鹤，外公折出来的千纸鹤瘦瘦的，特别好看。他家还有台脚踏风琴，印象最深的，夏天的午后，外公给我弹着不知名的曲子，边弹边唱，我挖着三色杯，在边上不知所以的默默听着。 外公是日本华侨，18岁回的上海，说着一口日本腔的上海话，我听不懂他在说什么，经常不耐烦地结束和他的聊天，他却乐此不疲地和我絮絮叨叨。小学时每逢暑假他来照看我，会买一大包乐事烧烤味薯片，会和我讲起他童年在福冈的趣事，下雪天穿着木屐上学啦、暑假偷偷去买糖精冰棍啦，学校不听话被老师打手心啦，会让我少看电视，陪我玩纸牌，会让我把饭吃干净，说这是一种完成任务…… 2018年的除夕，是我和外公吃的最后一顿年夜饭。外公从小时候的每周见一次，到现在的每年见一次，每次年夜饭桌上外公笑呵呵的问我在哪上班？工作是干什么的？最近好不好？都觉得好温暖好亲切，他的亲切今后再也见不到了。 想到身边外公留下的东西，翻出三支钢笔，哪一支是他送的不记得了，想到这里，眼泪一下子崩了，外公是爱我的，爱这个外孙女的，我怎么能不记得他送的是哪支钢笔了呢？我怎么那么薄情寡义呢？我好没用，这种事情都不记得，现在想问也问不到了。 好在2019年我结了婚，让外公看到我成家了，他记挂的事情应该少一件了吧。 关掉和我妈的对话框，扔掉了湿透的纸巾，内心恢复了平静。 外公，我会照顾好自己和妈妈的，希望你也是。","link":"/grandpa/index.html"},{"title":"404","text":"","link":"/404.html"},{"title":"interview","text":"面向对象：重点放在对象（数据）和对象的接口上，而非处理对象的工具/过程上 面向切面：反之 Java基础基本数据类型：int、short、long、float、double、char、boolean、byte ==与equals（==）： 基本类型比较值 引用类型比较引用地址 重写equals方法会把比较地址改为比较值 对象的hashcode相同，值不一定相同String str=”i”：常量池中String str=new String(“i”)：对内存中 final：类不可被继承，方法不可被重写，变量为常量不可被修改String：不可变StringBuffer：可变，线程安全，性能差些String Builder：可变，现成不安全，性能更好 抽象类不一定非要有抽象方法 常用类库： 集合Collection 反射动态代理JVM内存模型多线程 Spring基础 GrapgQL：在后端明确清晰的基础上提供可供前端自定义请求的http接口 Mybatis：非ORM框架JPA：ORM框架 SpringCloud Dubbo 框架封装原理 MySQL：引擎、基本数据类型、索引 Redis MongoDB MQ RocketMQ RabbitMQ Kafka AuthOShiro： 认证 提交认证-&gt;执行认证-&gt;认证-&gt;获取验证信息 提交授权-&gt; 执行授权-&gt; 授权-&gt;获取权限信息 tomcat docker kubernets 持续集成 docker compose 数据结构&amp;算法 排序 红黑树 二叉树 设计模式","link":"/interview/index.html"}],"posts":[{"title":"ubuntu服务器部署","text":"首先，你要有个服务器。。。目前市面上服务器供应商有很多，国内的阿里、国外的AWS、搬瓦工、Vultr、DigitalOcean等等，服务器实例创建完成后开始配置吧。 Login Remote Server1ssh username@ip-address Create new User and set its configuration 在ubuntu权限下设置 123sudo adduser userNamensudo visudouserName ALL=(ALL:ALL) ALL or see this Update hosts name临时变更主机名:“新主机名”可以用任何合法字符串来表示。采用这种方式，新主机名并不保存在系统中，重启系统后主机名将恢复为原先的主机名称。 hostname newName 永久修改主机名:重启系统后，参照上面介绍的快速查看主机名的办法来确认主机名有没有修改成功。 存放的是主机名 sudo vi /etc/hostname 添加newName sudo vi /etc/hosts 存放的是域名与ip的对应关系，域名与主机名没有任何关系，你可以为任何一个IP指定任意一个名字 禁止Root进行SSH远程登录 修改配置将PermitRootLogin yes改为PermitRootLogin no 重启ssh服务器,使配置变更生效;通过root登陆时，输入密码出现Permission denied, please try again.说明设置成功sudo /etc/init.d/ssh restart pem配置 切换用户在userName用户目录下 1su userName 创建.ssh 1cd ~\\nmkdir .ssh 添加公匙 12touch authorized_keysvi authorized_keys （important：公匙的添加一定要仔细！错一个字母就不匹配，无法登陆！！！） 配置完成后，可用密匙登陆:ssh -i ~/.ssh/joyce_ubuntu.pem ubuntu@ip-address OpenJDK 8 下载，坑的解决http://askubuntu.com/questions/464755/how-to-install-openjdk-8-on-14-04-lts 1sudo add-apt-repository ppa:openjdk-r/ppa 若报错：sudo: add-apt-repository: command not found执行： 123sudo apt-get install software-properties-common sudo apt-get updatejava -version Nginx123sudo apt-get install nginxsudo service nginx restartservice nginx {start|stop|status|restart|reload|configtest|} 用root权限起 123sudo lsof -i:80curl localhost:80netstat -an Tomcat 8安装tomcat8 不可安装在系统目录下，安装在用户目录下，系统目录下的操作命令与普通的不一致。 更新 1sudo apt-get update 下载(该网站搜索版本http://ftp.riken.jp/net/apache/tomcat/tomcat-8/) 1wget http://ftp.riken.jp/net/apache/tomcat/tomcat-8/v8.0.33/bin/apache-tomcat-8.0.33.tar.gz 创建文件夹 1mkdir demo 解压至目标文件夹 1tar -zxvf ~/apache-tomcat-8.0.33.tar.gz -C ~/demo tar命令： -c 创建.tar格式的文件 -x 解开.tar格式的文件 -f 使用归档文件 -v 显示详细信息 -t 查看包内文件 -j 使用baip2程序 -z 使用gzip程序 -p 打包时保留文件及目录的权限 -P 打包时保留文件及目录的绝对路径 -C 释放的目的地 修改工程名/bin/catalina.sh 1234cp catalina.sh catalina.sh.datevi catalina.sh添加(改为生产环境)JAVA_OPTS='-Dspring.profiles.active=prod -Xms512m -Xmx2048m -XX:PermSize=256M -XX:MaxNewSize=256m -XX:MaxPermSize=256m' 修改该tomcat中server.xml，修改相关port(避免与服务器中其他tomcat端口冲突) 将打包后的工程.war文件放入demo/webapps/跳过测试打包 1mvn -Pprod package -Dmaven.test.skip=true 打包 信息输出到文件 1mvn -Pprod package -Dmaven.test.skip=true &gt; demo.log Postgresql 更新 1sudo apt-get update 下载服务端 1sudo apt-get install postgresql postgresql-contrib pg启动／重启／停止 1sudo /etc/init.d/postgresql start/restart/stop 进入pg 1sudo -i -u postgres 带密码创建用户 1createuser username -P 不带密码创建用户 1createuser username 删除用户 1dropper username 创建数据库 1createdb dbname","link":"/2016/02/20/ubuntu-server/"},{"title":"TensorFlow安装","text":"read more on github 1. 安装1.1 ubuntu安装1.2 Mac OS安装TensorFlow Python API 依赖 Python 2.7 版本 12brew install python2.7pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl 1.3 使用容器VirtualEnv安装推荐使用 virtualenv 创建一个隔离的容器, 来安装 TensorFlow. 这样做能使排查安装问题变得更容易 123# 在 Mac 上:sudo easy_install pip # 如果还没有安装 pipsudo pip install --upgrade virtualenv 建立一个全新的 virtualenv 环境,将环境建在 ~/tensorflow 目录下 12virtualenv --system-site-packages ~/tensorflowcd ~/tensorflow 激活 virtualenv 123source bin/activate # 如果使用 bashsource bin/activate.csh # 如果使用 csh(tensorflow)$ # 终端提示符应该发生变化 在 virtualenv 内, 安装 TensorFlow 123456789(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;&lt;$url_to_binary.whl&gt;选择:# Mac只支持 CPUhttps://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl# Linux只支持 CPUhttps://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl 运行 TensorFlow 程序 12(tensorflow)$ cd tensorflow/models/image/mnist(tensorflow)$ python convolutional.py or 123456pythonimport tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print sess.run(hello)Hello, TensorFlow! 当使用完 TensorFlow 12# 停用 virtualenv(tensorflow)$ deactivate 1.4 从源码安装 clone TensorFlow 仓库 12# --recurse-submodules 参数是必须得, 用于获取 TesorFlow 依赖的 protobuf 库git clone --recurse-submodules https://github.com/tensorflow/tensorflow Mac OS安装所需依赖：Bazel, SWIG 12345678910111213141516 brew install bazel brew install swig ``` ## 2. 栗子### 2.1 For Java[example](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/java)JDK1.7* Start Using Apache Maven - 创建Maven工程 - 添加依赖 org.tensorflow tensorflow 1.1.0-rc1 12- 下载样例代码添加至```src/main/java/org/tensorflow/examples``` mkdir -p src/main/java/org/tensorflow/examples curl -L \"https://raw.githubusercontent.com/tensorflow/tensorflow/master/tensorflow/java/src/main/java/org/tensorflow/examples/LabelImage.java\" -o src/main/java/org/tensorflow/examples/LabelImage.java 123 - 编译 mvn compile exec:java ``` Start Using java and javac 2.2 Python Example","link":"/2017/10/08/TensorFlow%E5%AE%89%E8%A3%85/"},{"title":"crontab","text":"定时任务Cron表达式共七位，最少六位，表示如下，其中对英文缩写、特殊字符大小写不敏感 * * * * * * * 秒 分 时 日 月 周 年 0-59 0-59 0-23 1-31 1-12/JAN-DEC 0-7/MON-SAT 1900 可选 , - * / , - * / , - * / , - * ? / L W C , - * / , - * ? / L C # , - * / 符号表示如下： 符号 说明 * 重复当前位置的周期，如1 * * * * ?表示每分钟的第一秒执行 , 用于指定多个值，如0 10,20,30 * * * ?表示每小时的10、20、30分执行 ? 占位符 - 表示区间 / a/b表示以 a 为起点步长为 b 的时间序列，如5/10 * * * * ?表示每分钟第5、15、25、35、45、55秒执行 L 月份最后一天或星期六，周位上 6L 表示月份的最后一个周五执行，L和 W 可以在日位中联合使用，LW 表示这个月最后一周的工作日 W 后边最近的工作日，1W 1日如果是周五，那就在4日执行，不可跨月，L和 W 可以在日位中联合使用，LW 表示这个月最后一周的工作日 # a#b 表示当月第 b 个星期 a，如 6#1 当月第一个星期五 C 关联日历计算结果 场景示例1.Mac设置定时任务1234567891011121314151617# 确保存在文件 /etc/crontab，若没有则新建sudo touch /etc/crontab# 编辑crontab，写入定时脚本vi /etc/crontab# 生效定时脚本crontab /etc/crontab# 查看定时任务是否启动sudo launchctl list | grep cron# 状态查看sudo /usr/sbin/cron start | restart | stop# 查看已有任务列表sudo crontab -l# 编辑任务sudo crontab -e# 删除 定时脚本 文件sudo crontab -r 我用terminal-notifier来实现terminal推送提醒功能，脚本如下： 1234# 每日凌晨更新homebrew30 1 * * * * brew upadte# 半小时起来走动30 */1 * * * /usr/local/bin/terminal-notifier -title &quot;休息，休息一下&quot; -message &quot;你再不站起来要变死肥宅了!&quot; -ignoreDnD -group 1 2.Java中的定时任务需求2.1 java.util.Timer (since JDK1.3)执行时单线程，当抛出运行时异常时Timer 将停止所有的任务执行，会影响其他任务 12345678910111213public void demo() { // 定义一个任务 TimerTask timerTask = new TimerTask() { @Override public void run() { System.out.println(&quot;Run timerTask：&quot; + System.currentTimeMillis()); } }; // 计时器 Timer timer = new Timer(); // 添加执行任务（延迟 1s 执行，每 3s 执行一次） timer.schedule(timerTask, 1000, 3000);} 2.2 java.util.concurrent.ScheduledExecutorService (since JDK1.5)不影响其他任务 123456789public void demo() { // 创建任务队列 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10); // 10 为线程数量 // 执行任务 scheduledExecutorService.scheduleAtFixedRate(() -&gt; { System.out.println(&quot;Run Schedule：&quot; + System.currentTimeMillis()); }, 1, 3, TimeUnit.SECONDS); // 1s 后开始执行，每 3s 执行一次} 2.3 @Scheduled (based on Spring)Spring自动加载和管理该定时任务 12345678910111213@SpringBootApplication@EnableScheduling // 开启定时任务public class DemoApplication { ...}@Component public class TaskUtils { @Scheduled(cron = “0 1 * * * ” ) public void doTask(){ System.out.println(“执行定时任务&quot;); }} 2.4 任务调度框架Quartz在项目中使用需要引入quartz依赖，并且quartz有其独立的数据库，来支撑复杂的任务调度，详见官方文档","link":"/2020/11/03/crontab/"},{"title":"在本机上同时使用GitHub与GitLab","text":"在本机上同时使用GitHub与GitLab 进入.ssh文件夹 1cd .ssh/ 修改config文件(若没有，touch config) 12345678910# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 测试连接 1ssh -T git@github.com 若输出如下，则连接成功 1Hi BreadKid! You've successfully authenticated, but GitHub does not provide shell access. 参考博客","link":"/2017/01/17/git-config/"},{"title":"Mac下的配置文件","text":"profilelocation: /etc/profile 设置系统级的环境变量和启动程序 会对所有用户生效 用户登录（login）时，文件会被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置 修改完后用source生效:source /etc/profile bash_profilelocation:~/.bash_profile 用户级的设置，只针对单个用户有效 执行顺序/etc/profile &gt; ~/.bash_profile &gt; ~/.bash_login &gt; ~/.profile","link":"/2018/06/06/mac-files/"},{"title":"nginx","text":"Nginx负载均衡有4种方案配置 轮询：轮询即Round Robin，根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器上 最少连接 least_conn：Web请求会被转发到连接数最少的服务器上 IP地址哈希 ip_hash：前述的两种负载均衡方案中，同一客户端连续的Web请求可能会被分发到不同的后端服务器进行处理，因此如果涉及到会话Session，那么会话会比较复杂。常见的是基于数据库的会话持久化。要克服上面的难题，可以使用基于IP地址哈希的负载均衡方案。这样的话，同一客户端连续的Web请求都会被分发到同一服务器进行处理 基于权重 weight基于权重的负载均衡即Weighted Load Balancing，这种方式下，可以配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器","link":"/2018/02/12/nginx/"},{"title":"免费CloudFlare SSL配置","text":"现在好多网站都转成了https，外加小程序强制https，这小网站算凑凑热闹。网上查阅些过来人的教学博客，发现大家都用CloudFlare的免费SSL，我的网站本来是基于Gitpages搭建的，虽然Gitpages提供了Https的设置(相关官方文档)，但要用该功能的话必须是github.io的域名。我用自己的breadykid.com域名，所以需要折腾一下。 Step1:在CF添加域名，获取提供的NameServer注册CloudFlare账号，创建站点获得CloudFlare提供的DNS。 添加站点，扫描域名输入个人域名开始扫描扫描完毕 添加DNS Records添加完成 按照step2去所在的域名服务商那修改DNS 选择版本，穷困的我当然选免费的啦～～～ 检查网站是否激活网站已经处于激活状态了 配置选项,flexible为了访客到cf的过程是加密的，而cf到gitpages不加密 以上，完成后等待CloudFlare添加的网站为激活状态，使用https打开个人网站。 Step2:修改域名DNS服务器去自己的域名服务商那边修改DNS，我在万网买的，以下是万网界面。 Step3:修改Hexo的配置文件 修改站点配置文件_config.yml12url: https://www.yoursite.com # with the https protocolenforce_ssl: www.yoursite.com # without any protocol 至此，网站已经可以用https访问，但必须手动输入https前缀才行，这里我们将其改为强制https。* 修改主题配置文件，以下为Next主题配置文件，themes/next/layout/_layout.swig，在头部加上： 12345&lt;script type=&quot;text/javascript&quot;&gt; var host = &quot;yoursite.com&quot;; if ((host == window.location.host) &amp;&amp; (window.location.protocol != &quot;https:&quot;)) window.location.protocol = &quot;https&quot;;&lt;/script&gt; 至此，网站跳转https全部实现。 参考:CloudFlare教程next主题强制https","link":"/2017/01/16/%E5%85%8D%E8%B4%B9CloudFlare-SSL%E9%85%8D%E7%BD%AE/"},{"title":"微信H5支付","text":"微信解读 使用场景商户已有H5商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。 步骤 商户下发图文消息或者通过自定义菜单吸引用户点击进入商户网页。 进入商户网页，用户选择购买，完成选购流程。 简述微信的H5页面支付只需在商家的付款页面上调用wechat的API即可，调用时需要提供一些指定参数，所以，前端页面代码只需复制微信官方提供的页面方法即可；而后端需要做的，就是将支付所需参数生成正确并传递到页面即可。 网页端调起支付API所需参数详见微信官方文档 wechat link在微信浏览器里面打开H5网页中执行JS调起支付。接口输入输出数据格式为JSON。注意：WeixinJSBridge内置对象在其他浏览器中无效。列表中参数名区分大小，大小写错误签名验证会失败。 网页端接口参数列表: | 名称 |变量名|必填|类型|示例|描述|| 公众号id | appId | 是 | String(16) | wx8888888888888888 | 公众号名称，由商户传入，商户注册具有支付权限的公众号成功后即可获得 || 时间戳 | timeStamp | 是 | String(32) | 1414561699 | 当前的时间，自1970年以来的秒数，其他详见时间戳规则 || 随机字符串 | nonceStr | 是 | String(32) | 5K8264ILTKCH16CQ2502SI8ZNMTM67VS | 随机字符串，不长于32位。||订单详情扩展字符串|package|是|String(128)|prepay_id=123456789|统一下单接口返回的参数值，提交格式必须如示例所示||签名方式| type | 是 | String(32) | MD5 |签名算法|| 时间戳 | timeStamp | 是 | String(64) | C380BEC2BFD727A4B6845133519F3AD6 |签名| 签名生成算法时间戳规则随机数生成算法 网页内支付接口err_msg返回结果值说明: |返回值|描述||ok|支付成功，仅在用户成功完成支付时返回||cancel|支付过程中，用户取消(可以统一处理为用户遇到错误或者主动放弃，不必细化区分)||fail|支付失败(可以统一处理为用户遇到错误或者主动放弃，不必细化区分)| 网页端调起支付API示例代码123456789101112131415161718192021222324252627282930313233function onBridgeReady(){ WeixinJSBridge.invoke( 'getBrandWCPayRequest', { &quot;appId&quot; ： &quot;wx2421b1c4370ec43b&quot;, //公众号名称，由商户传入 &quot;timeStamp&quot;：&quot; 1395712654&quot;, //时间戳，自1970年以来的秒数 &quot;nonceStr&quot; ： &quot;e61463f8efa94090b1f366cccfbbb444&quot;, //随机串 &quot;package&quot; ： &quot;prepay_id=u802345jgfjsdfgsdg888&quot;, &quot;signType&quot; ： &quot;MD5&quot;, //微信签名方式： &quot;paySign&quot; ： &quot;70EA570631E4BB79628FBCA90534C63FF7FADD89&quot; //微信签名 }, function(res){ if (res.err_msg == &quot;get_brand_wcpay_request:ok&quot;) { alert(&quot;pay success&quot;); } if (res.err_msg == &quot;get_brand_wcpay_request:cancel&quot;) { alert(&quot;pay cancel&quot;); } if (res.err_msg == &quot;get_brand_wcpay_request:fail&quot;) { alert(&quot;pay failed&quot;); } } ); } if (typeof WeixinJSBridge == &quot;undefined&quot;){ if( document.addEventListener ){ document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); }else if (document.attachEvent){ document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); } }else{ onBridgeReady(); } 后端代码剖析与支付H5页面交互类其中notify_url与设置详见下图支付授权目录：xzl.gxcm.com.cn/#/为iOS路径xzl.gxcm.com.cn/#/course/为android路径支付授权目录.png?nolink微信支付设置：需要为测试人员设置白名单，否则无法支付开发配置.png?nolink 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import com.*.CommonUtil;import com.*.MD5SignUtil;import com.*.PayUtil;import com.*.WeChatConnector;import org.springframework.ui.Model;import java.util.HashMap;import java.util.Map;import java.util.UUID;public class WechatPayService{ private static Log log= LogFactory.getLog(WechatPayService.class); public String wechatPay(Model model, String openId, String price) throws Exception { String paternerKey = &quot;demo123456demo123456demo123456de&quot;; // 密钥，需登录微信支付平台获得 String appId = WeChatConnector.getMpConfigStorage().getAppId(); // 公众号名称，由商户传入 String timestamp = System.currentTimeMillis() / 1000 + &quot;&quot;; String nonceStr = UUID.randomUUID().toString().substring(0, 32); String num = (Double.parseDouble(price) * 100 + &quot;&quot;).substring(0, (Double.parseDouble(price) * 100 + &quot;&quot;).indexOf(&quot;.&quot;)); // 对页面传入的价格进行处理 PayUtil payUtil = new PayUtil(); // get prepayid Map map = new HashMap(); map.put(&quot;appid&quot;, appId); map.put(&quot;mch_id&quot;, &quot;1235171102&quot;); // 商户号 map.put(&quot;nonce_str&quot;, nonceStr); // 随机数 map.put(&quot;body&quot;, &quot;高校传媒&quot;); // 产品名 map.put(&quot;out_trade_no&quot;, payUtil.orderNum()); map.put(&quot;total_fee&quot;, price); // 总价，以“分”为单位 map.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;); // request.getRemoteAddr() map.put(&quot;notify_url&quot;, &quot;http://xzl.gxcm.com.cn/wechat/gitPay&quot;); // 支付授权目录，设置见下图 map.put(&quot;trade_type&quot;, &quot;JSAPI&quot;); // 支付接口类型 map.put(&quot;attach&quot;, courseId); // 课程Id map.put(&quot;openid&quot;, openId); // 用户的openId String paySign = MD5SignUtil.sign(CommonUtil.FormatBizQueryParaMap(map), paternerKey); map.put(&quot;sign&quot;, paySign); // sign String xml = CommonUtil.ArrayToXml(map); String prepayid = payUtil.getPrepayid(xml); // h5 param Map signMap = new HashMap(); model.addAttribute(&quot;appId&quot;, appId); model.addAttribute(&quot;timeStamp&quot;, timestamp); model.addAttribute(&quot;package&quot;, &quot;prepay_id=&quot; + prepayid); model.addAttribute(&quot;nonceStr&quot;, nonceStr); model.addAttribute(&quot;signType&quot;, &quot;MD5&quot;); signMap.put(&quot;appId&quot;, appId); signMap.put(&quot;timeStamp&quot;, timestamp); signMap.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepayid); signMap.put(&quot;signType&quot;, &quot;MD5&quot;); signMap.put(&quot;nonceStr&quot;, nonceStr); String paySignH5 = MD5SignUtil.sign(CommonUtil.FormatBizQueryParaMap(signMap), paternerKey); model.addAttribute(&quot;paySign&quot;, paySignH5); String url = String.format(&quot;checkout/partials/wechatPayForm&quot;, model); return url; } } 交互所需参数生成工具类CommonUtilHttpClientUtilMD5SignUtilMD5UtilMapKeyComparatorUtilPayUtil CommonUtil.java1234567891011121314151617181920212223242526272829303132333435363738 import java.util.*; public class CommonUtil { // 转换 public static String ArrayToXml(Map&lt;String, String&gt; arr) { String xml = &quot;&lt;xml&gt;&quot;; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = arr.entrySet().iterator(); while (iter.hasNext()) { Map.Entry&lt;String, String&gt; entry = iter.next(); String key = entry.getKey(); String val = entry.getValue(); xml += &quot;&lt;&quot; + key + &quot;&gt;&quot; + val + &quot;&lt;/&quot; + key + &quot;&gt;&quot;; } xml += &quot;&lt;/xml&gt;&quot;; return xml; } // 字典排序 public static String FormatBizQueryParaMap(Map map) throws Exception { StringBuffer sb = new StringBuffer(); if (map == null || map.isEmpty()) { return null; } Map&lt;String, String&gt; sortMap = new TreeMap&lt;String, String&gt;(new MapKeyComparatorUtil()); sortMap.putAll(map); Map&lt;String, String&gt; resultMap = sortMap; for (Map.Entry&lt;String, String&gt; entry : resultMap.entrySet()) { sb.append(entry.getKey() + &quot;=&quot; + entry.getValue() + &quot;&amp;&quot;); } return sb.toString().substring(0,sb.toString().length()-1); }} HttpClientUtil.java123456789101112131415161718192021222324import org.apache.commons.httpclient.methods.PostMethod;public class HttpClientUtil { private static HttpClientUtil instance = null; private HttpClientUtil() { } public static HttpClientUtil getInstance() { if (instance == null) { instance = new HttpClientUtil(); } return instance; } // 发送 post请求 // @param httpUrl 地址 public PostMethod postMethod(String httpUrl) { PostMethod postMethod=new PostMethod(httpUrl);// 创建httpPost return postMethod; }} MD5SignUtil.java1234567public class MD5SignUtil { public static String sign(String content, String key) throws Exception { String signStr = content + &quot;&amp;key=&quot; + key; return MD5Util.MD5(signStr).toUpperCase(); }} MD5Util.java1234567891011121314151617181920212223242526import java.security.MessageDigest;public class MD5Util { public final static String MD5(String s) { char hexDigits[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; try { byte[] btInput = s.getBytes(); MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;); mdInst.update(btInput); byte[] md = mdInst.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) { byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; } return new String(str); } catch (Exception e) { e.printStackTrace(); return null; } }} MapKeyComparatorUtil.java123456789import java.util.Comparator;public class MapKeyComparatorUtil implements Comparator&lt;String&gt; { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); }} PayUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.SimpleHttpConnectionManager;import org.apache.commons.httpclient.methods.PostMethod;import org.apache.commons.httpclient.params.HttpClientParams;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.codehaus.jettison.json.JSONObject;import java.io.IOException;import java.io.InputStream;import java.util.Random;public class PayUtil { private static Log log = LogFactory.getLog(PayUtil.class); public static String URL = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;; public String getPrepayid(String xml) { log.warn(xml); try { JSONObject jo = getPrepayJson(xml); JSONObject element = jo.getJSONObject(&quot;xml&quot;); String prepayid = (element.get(&quot;prepay_id&quot;)).toString(); return prepayid.substring(1, prepayid.length() - 1); } catch (Exception e) { e.printStackTrace(); } return null; } @SuppressWarnings(&quot;deprecation&quot;) public JSONObject getPrepayJson(String xml) { HttpClient httpClient = new HttpClient(new HttpClientParams(), new SimpleHttpConnectionManager(true)); InputStream is = null; PostMethod method = null; try { method = HttpClientUtil.getInstance().postMethod(URL); method.setRequestBody(xml); method.getParams().setContentCharset(&quot;UTF-8&quot;); // UTF-8 httpClient.executeMethod(method); //读取响应 is = method.getResponseBodyAsStream(); JSONObject o = XmlJsonUtil.xmlJSON(is); return o; } catch (Exception e) { e.printStackTrace(); } finally { if (method != null) { method.releaseConnection(); } if (is != null) { try { is.close(); } catch (IOException e1) { e1.printStackTrace(); } } } return null; } // @return time&amp;randomNum public String orderNum() { String chars = &quot;0123456789&quot;; String order = System.currentTimeMillis() + &quot;&quot;; String res = &quot;&quot;; for (int i = 0; i &lt; 19; i++) { Random rd = new Random(); res += chars.charAt(rd.nextInt(chars.length() - 1)); } order += res; return order; }} 支付成功发送模版消息123456789101112131415161718192021// wechat shopping receipt// 发送模版消息// @param openId// @param pricepublic void sendShoppingReceipt(String openId, String price) { WxMpTemplateMessage wxMpTemplateMessage = new WxMpTemplateMessage(); wxMpTemplateMessage.setToUser(openId); wxMpTemplateMessage.setTemplateId(&quot;VTevmK1xd15sAlMPOmna1bXnh-l46Epw9DwrqHvkKVo&quot;); // 模版ID wxMpTemplateMessage.setUrl(&quot;bige.t.beeoz.com/#/owncourse&quot;);// user center page wxMpTemplateMessage.setTopColor(&quot;#173177&quot;); wxMpTemplateMessage.getDatas().add(new WxMpTemplateData(&quot;first&quot;, &quot;购买成功&quot;, &quot;#173177&quot;)); wxMpTemplateMessage.getDatas().add(new WxMpTemplateData(&quot;product&quot;, &quot;在线课程&quot;, &quot;#173177&quot;)); wxMpTemplateMessage.getDatas().add(new WxMpTemplateData(&quot;price&quot;, price, &quot;#173177&quot;)); wxMpTemplateMessage.getDatas().add(new WxMpTemplateData(&quot;time&quot;, System.currentTimeMillis() + &quot;&quot;, &quot;#173177&quot;)); wxMpTemplateMessage.getDatas().add(new WxMpTemplateData(&quot;remark&quot;, &quot;如有疑问，请咨询公众号客服&quot;, &quot;#173177&quot;)); try { WeChatConnector.getMpService().templateSend(wxMpTemplateMessage); } catch (WxErrorException e) { e.printStackTrace(); }}","link":"/2016/01/10/%E5%BE%AE%E4%BF%A1H5%E6%94%AF%E4%BB%98/"},{"title":"数据库中的count","text":"count(*) 和 count(1)和count(列名)区别 执行效果上： • count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL • count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL • count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。 执行效率上： • 列名为主键，count(列名)会比count(1)快 • 列名不为主键，count(1)会比count(列名)快 • 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（） • 如果有主键，则 select count（主键）的执行效率是最优的 • 如果表只有一个字段，则 select count（）最优。","link":"/2020/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84count/"},{"title":"树莓派温湿度监督玩具","text":"基于 Rasperry Pi 3B and Arduino 公司为了防止夏天机房温度过高，需要一个温度监测工具，其实市面上的小米温度监测只要35块，但是想着可自定义扩展的需要，就做了一个从硬件到软件的温湿度监测系统，好在用了一个周末做出来了，考虑到之后还要增加电压警告等功能，选型如下： 开发板：（来自万能的大淘宝） Rasberry Pi 3B：中央控制服务器，负责与互联网的通信、采样存储 Arduino 上报的状态数据、提供/调用API以方便用其他终端控制。 Arduino UNO：负责传感器采样，和 RPi 进行通信。 温度传感器：DHT22 语言：Python3,Java8 存储：Mysql,Redis Arduino1234567891011121314151617181920#include &quot;DHT.h&quot;DHT dht(2, DHT22);void setup(){ Serial.begin(9600); dht.begin();}void loop(){ float humidity = dht.readHumidity(); float temperature = dht.readTemperature(); Serial.print(&quot;Humidity: &quot;); Serial.print(humidity); Serial.print(&quot; &quot;); Serial.print(&quot;Temperature: &quot;); Serial.println(temperature); delay(2000);} RasberryPi 3B安装系统镜像:raspbian-stretch-litemicroSD卡:16G，推荐8G以上 将SD卡格式化:(Mac)磁盘工具–&gt;抹掉–&gt;MS-DOS(FAT)–&gt;抹掉 终端df-h查看挂载，SD 卡假设为 /dev/disk2s1 卸载 SD 卡diskutil unmount /dev/disk2s1 diskutil list 确认 /dev/disk2 下的 disk2 官网下载镜像，写入 SD 卡sudo dd bs=4m if=本机镜像路径 of=/dev/disk2查看进度可以另起终端 sudo kill -INFO $(pgrep ^dd) 由于树莓派默认不开启 ssh，写入成功后在 /boot/ 创建无后缀的文件名为 ssh 的文件 设置自动连接 Wi-Fi:在 /boot/ 下创建 wpa_supplicant.conf 12345678country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ scan_ssid=1#SSID被隐藏时设置 ssid=&quot;TaiGe&quot;#Wi-Fi名 psk=&quot;HaoyunHu888&quot;#Wi-Fi密码} 弹出SD卡diskutil unmountDisk /dev/disk2 以上，RasberryPi的系统安装完成，可以将SD卡插入开发版上电开机了 登录系统SSH12ssh pi@ipdefault password: raspberry 通过路由器查看树莓派的当前ip: 打开网页192.168.1.1，登录系统 状态/用户侧信息/以太网接口信息/，找到客户端名称为raspberrypi的IP地址关机sudo shutdown -h now，重新上电后会自动开机 系统安装参考 查看rpiIP参考 RaspberryPi读取Arduino数据安装Python31sudo aptitude install python-dev 安装Python的GPIO模块用于控制LED、电机等 12sudo apt-get install rpi.gpio 安装Serial用于串口通信及USB通信sudo apt-get install python-serial 安装串口调试程序minicom是linux平台串口调试工具，可以用它来读取Arduino通过USB串口发送的传感器数值。 在RaspberryPi上安装minicom：sudo apt-get install minicom 配置minicom： minicom启动：minicom -b 9600 -D /dev/ttyACM0 -b代表波特率 -D代表端口 /dev/ttyACM0 代表打开与Arduino相连的端口 Python打印数据show.py 123456import serialser = serial.Serial('/dev/ttyACM0',9600)info = ser.readline()while info: print(info) info = ser.readline() Python调用http API安装requestssudo pip install requests 后台运行py脚本nohup python api.py &amp;","link":"/2018/05/10/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E7%9D%A3%E7%8E%A9%E5%85%B7/"},{"title":"版本命名规范","text":"上家公司在发版时对tag的命名一直不是很规范，参考了各大网站及博客上的说明，做个笔记。 版本号格式：常见格式：[name].A.B.C-[state]name：可选字段,一般为 v,表示 version；A：Major主版本号，一般当软件整体重写，或当API兼容性变化时递增；B：Minor次版本号，当增加功能时（API兼容性不变化）递增；C：Patch修订号，Bug修复时（API兼容性不变化）递增；state：可选字段,表示版本状态，用alpha等修饰词 Detail A，B，C为非负整数，且不得包含前导0，按数值递增。🌰1.2.0-&gt;1.3.0-&gt;1.4.0 0.B.C表示处于开发阶段，API不稳定，1.0.0表明已有稳定版本API 当API兼容性变化时，A++，B=C=0; 当功能新增或API标记为deprecated弃用时，B++，C=0； 当Bug Fix时，C++； 先行版本号（Pre-release）表示该版本不稳定，可能有兼容问题。格式1.0.0.[a-c][正整数]🌰1.0.0.a3 1.0.0.b89 1.0.0.c1999008 开发版本号多用于CI-CD，格式A.B.C.dev[正整数]。🌰1.0.1.dev5 版本号排序规则： 主版本号，次版本号，修订号🌰1.0.0&lt;1.0.1&lt;1.1.1&lt;2.0.0 对先行版本号与开发版本号🌰1.0.0.a10&lt;1.0.0 2.1.0.dev2&lt;2.1.0 存在字母，按ASCII码排序🌰1.0.0.a10&lt;1.0.0.b10 Tip:版本一经发布，不得修改！ 修饰词 alpha 内部版本 beta 测试版 demo 演示版 enhance 增强版 free 自由版 full version 完整版，正式版 lts 长期维护版 release 发行版 rc 即将正式发布 standard 标准版 ultimate 旗舰版 upgrade 升级版 参考： 语义化版本 2.0.0 理解版本命名及限定规则 《软件工程》第十版 第25章 ISBN：9787111589105","link":"/2018/03/07/%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/"},{"title":"Springboot2.0的启动详解","text":"抄袭自:Spring Boot1.3.3启动流程详解 0.先来说说启动类的注解123456@SpringBootApplicationpublic class LearnApplication { public static void main(String[] args) { SpringApplication.run(LearnApplication.class, args); }} 其中，类注解@SpringBootApplication的实现为 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { } 其中，@SpringBootConfiguration,@EnableAutoConfiguration和@ComponentScan为主要注解，用这三个注解代替启动类上的@SpringBootApplication也能使工程正常运行。 详解@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan三个注解主要做一件事：注册bean到spring容器，通过不同条件不同方式来完成。 @SpringBootConfiguration 其底层为 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {} 123456 ```@Configuration```是等同于String的xml文件配合```@Bean```注解，可以配置需要Spring容器管理的bean。 * 自动配置 @EnableAutoConfiguration 注解源码 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage // 主要注解，通过导入方式，将制定class注册到Spring容器 @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { } 1234567 ```@EnableAutoConfiguration```从classpath中搜索所有的```META-INF/spring.factories```配置文件，将```org.springframework.boot.autoconfigure.EnableutoConfiguration```对应的配置项通过反射实例化为对应标注了```@Configuartion```的JavaConfig形式的IoC容器配置类，汇总成一个，加载到IoC容器。* 组件扫描 @ComponentScan 注解源码 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Repeatable(ComponentScans.class) public @interface ComponentScan { // 对应的包扫描路径 @AliasFor(&quot;basePackages&quot;) String[] value() default {}; // 对应的包扫描路径 @AliasFor(&quot;value&quot;) String[] basePackages() default {}; // 指定具体扫描类 Class&lt;?&gt;[] basePackageClasses() default {}; // 对应bean名称生成器，默认BeanNameGenerator.class Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; // 对应监测到的bean的scope范围 Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class; // 为监测到的组件生成代理 ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT; // 控制符合组件检测条件的类文件，默认在包扫描下 String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN; // 是否对带@Component，@Repository，@Service，@Controller自动检测，默认开启 boolean useDefaultFilters() default true; // 指定定义Filter满足条件的组件 Filter[] includeFilters() default {}; // 排除定义Filter不满足条件的组件 Filter[] excludeFilters() default {}; // 扫描到的类进行懒加载，默认关闭 boolean lazyInit() default false; } 12345678 ```@ComponentScan```该注解告知Spring要扫描那些类或包，默认扫描该注解所在包及子包下所有类。 所以在SpringBoot项目中，启动类放在顶层目录中，以便扫描到所有类。 扫描特定注解注释的类，将其注册到Spring容器中。### 1.由如下代码启动在这个main方法中，调用了SpringApplication的静态run方法，并将Application类对象和main方法的参数args作为参数传递了进去。 public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args);} 12### 2.在这个静态方法中，创建SpringApplication对象，并调用该对象的run方法。 public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String… args) { return run(new Class[]{primarySource}, args);} public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return (new SpringApplication(primarySources)).run(args);} 12345678910### 3.进入SpringApplication类中看到 构造函数中，初始化SpringApplication对象的成员变量：* `resourceLoader `:由传参获得* `primarySources`:由传参获得* `webApplicationType`* `initializers`* `listeners`* `mainApplicationClass` /** * Create a new {@link SpringApplication} instance. The application context will load * beans from the specified primary sources (see {@link SpringApplication class-level} * documentation for details. The instance can be customized before calling */ public SpringApplication(Class&lt;?&gt;... primarySources) { this(null, primarySources); } /** * Create a new {@link SpringApplication} instance. The application context will load * beans from the specified primary sources (see {@link SpringApplication class-level} * documentation for details. The instance can be customized before calling */ @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = deduceWebApplicationType(); setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } 123#### 3.1 webApplicationType：通过类判断应用类型 /** * The class name of application context that will be used by default for reactive web * environments. */ public static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = &quot;org.springframework.&quot; + &quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;; private static final String REACTIVE_WEB_ENVIRONMENT_CLASS = &quot;org.springframework.&quot; + &quot;web.reactive.DispatcherHandler&quot;; private static final String MVC_WEB_ENVIRONMENT_CLASS = &quot;org.springframework.&quot; + &quot;web.servlet.DispatcherServlet&quot;; public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { ... this.webApplicationType = deduceWebApplicationType(); ... } 123`deduceWebApplicationType`方法返回的是`WebApplicationType`（表示web应用类型的枚举类），通过查看类是否存在数组中所包含的类来判断应用类型 private WebApplicationType deduceWebApplicationType() { // 响应式web应用 if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) { return WebApplicationType.REACTIVE; } for (String className : WEB_ENVIRONMENT_CLASSES) { // 不是web应用 if (!ClassUtils.isPresent(className, null)) { return WebApplicationType.NONE; } } // 基于servlet的web应用 return WebApplicationType.SERVLET; } 1234#### 3.2 setInitializers：设置initializers成员变量 public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { ... setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); ... } /** * Sets the {@link ApplicationContextInitializer} that will be applied to the Spring */ public void setInitializers( Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) { this.initializers = new ArrayList&lt;&gt;(); this.initializers.addAll(initializers); } 1234调用`getSpringFactoriesInstances`获取`ApplicationContextInitializer`类型对象的列表，该方法中，通过`SpringFactoriesLoader.loadFactoryNames(type, classLoader)`获取所有Spring Factories名字，再调用`createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names)`根据type创建对象，再返回一个List&lt;type&gt; private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) { return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {}); } private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // 使用名字保证唯一性，避免重复冲突 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances; } 1 public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); } private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) { return result; } else { try { Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Entry&lt;?, ?&gt; entry = (Entry)var6.next(); List&lt;String&gt; factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue())); result.addAll((String)entry.getKey(), factoryClassNames); } } cache.put(classLoader, result); return result; } catch (IOException var9) { throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var9); } } } 1234其中，Spring Factories名字从如下路径读取 Enumeration urls = classLoader != null ? classLoader.getResources(“META-INF/spring.factories”) : ClassLoader.getSystemResources(“META-INF/spring.factories”); 123成员变量会被初始化为如下5个类对象组成的list Application Context Initializers初始化ApplicationContext，在refresh前调用org.springframework.context.ApplicationContextInitializer=\\ 为ApplicationContext添加检查配置，并在常见错误配置时打印警告信息BeanFactoryPostProcessororg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\ 为ApplicationContext设置idorg.springframework.boot.context.ContextIdApplicationContextInitializer,\\ 从ApplicationContext环境配置中读取Initializer并应用org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\ 为ApplicationContext设置环境变量，以便单元测试中使用服务器正监听的端口号org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer 123通过`createSpringFactoriesInstances`创建ApplicationContextInitializer实例 private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) { List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size()); for (String name : names) { try { Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader); Assert.isAssignable(type, instanceClass); Constructor&lt;?&gt; constructor = instanceClass .getDeclaredConstructor(parameterTypes); T instance = (T) BeanUtils.instantiateClass(constructor, args); instances.add(instance); } catch (Throwable ex) { throw new IllegalArgumentException( &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex); } } return instances; } 12345#### 3.3 setListeners：设置listeners成员变量listeners成员变量是ApplicationListener&lt;?&gt;的集合 public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { ... setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); ... } /** * Sets the {@link ApplicationListener}s that will be applied to the SpringApplication * and registered with the {@link ApplicationContext}. */ public void setListeners(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners) { this.listeners = new ArrayList&lt;&gt;(); this.listeners.addAll(listeners); } 123和成员变量initializers调用一样的方法,成员变量会被初始化为如下10个类对象组成的list Application Listeners观察者模式的监听器接口，监听各种ApplicationEventorg.springframework.context.ApplicationListener=\\ 清缓存org.springframework.boot.ClearCachesApplicationListener,\\ 父context关闭，关闭当前ApplicationContextorg.springframework.boot.builder.ParentContextCloserApplicationListener,\\ 当系统属性System.encoding与配置的spring编码不同时，打印错误信息，并终止系统启动org.springframework.boot.context.FileEncodingApplicationListener,\\ 根据属性spring.output.ansi.enabled配置ANSI输出（彩色输出日志）org.springframework.boot.context.config.AnsiOutputApplicationListener,\\ 搜索加载配置文件，并根据配置文件设置Environment与Applicationorg.springframework.boot.context.config.ConfigFileApplicationListener,\\ 加载并转发事件至context.listener.classes中配置的ApplicationLIstenerorg.springframework.boot.context.config.DelegatingApplicationListener,\\ 程序正常启动成功：将classpath打印至debug日志程序正常启动失败：将classpath打印至info日志org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\ 根据配置，适当的时候初始化与配置日志系统org.springframework.boot.context.logging.LoggingApplicationListener,\\ 若classpath中存在类liquibase.servicelocator.ServiceLocator,替换成适用于springboot的版本org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener 1234567#### 3.4 deduceMainApplicationClass：在deduceMainApplicationClass方法中，通过获取当前调用栈，找到入口方法main所在的类，并将其复制给SpringApplication对象的成员变量mainApplicationClass（即创建的`SpringApplication.class`） public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { ... this.mainApplicationClass = deduceMainApplicationClass(); } private Class&lt;?&gt; deduceMainApplicationClass() { try { StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { // 获取当前调用栈 if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) { // 找到main方法所在类并返回 return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null; } 123### 4.SpringApplication对象的run方法以上为初始化过程，得到了一个SpringApplication对象，接下来将调用其静态`run`方法。SpringApplication对象的run方法创建并刷新ApplicationContext，按照执行顺序，介绍该方法所做的工作。 public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } public ConfigurableApplicationContext run(String... args) { // StopWatch是来自org.springframework.util的工具类，可以用来方便的记录程序的运行时间 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 设置headless模式 configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } listeners.started(context); callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, listeners, exceptionReporters, ex); throw new IllegalStateException(ex); } listeners.running(context); return context; } 12345#### 4.1 headless模式设置系统属性java.awt.headless private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;; private boolean headless = true; public ConfigurableApplicationContext run(String... args) { ... // 设置headless模式 configureHeadlessProperty(); ... } private void configureHeadlessProperty() { System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty( SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless))); } 123456#### 4.2 SpringApplicationRunListeners在SpringApplication对象的run方法执行的不同阶段，去执行一些操作，并且这些操作是可配置的。 加载SpringApplicationRunListener时，使用的是跟加载ApplicationContextInitializer和ApplicationListener时一样的方法，加载内容如下： Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\ RunListener是在SpringApplication对象的run方法执行到不同的阶段时，发布相应的event给SpringApplication对象的成员变量listeners中记录的事件监听器。org.springframework.boot.context.event.EventPublishingRunListener 1 public ConfigurableApplicationContext run(String... args) { ... SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { // 把main函数的args参数当做一个PropertySource来解析 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 配置环境:读取执行配置文件：profiles与properties ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 跳过特定Bean的配置 configureIgnoreBeanInfo(environment); // banner打印 Banner printedBanner = printBanner(environment); // 创建会话 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // 准备会话 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新会话 refreshContext(context); // 刷新会话后执行 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } listeners.started(context); callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, listeners, exceptionReporters, ex); throw new IllegalStateException(ex); } listeners.running(context); return context; } private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args)); } ``` Tips：Environment代表着程序运行的环境，主要包含了两种信息 profiles，用来描述哪些bean definitions是可用的 properties，用来描述系统的配置，其来源可能是配置文件、JVM属性文件、操作系统环境变量等等 再里面的方法就不点进去一一看了，大致酱。","link":"/2018/03/14/springboot-start/"},{"title":"树莓派烧录系统","text":"烧录工具 官方工具Raspberry Pi Imager 通用工具etcher Windows下的工具Win32 DiskImage 系统 中文社区 步骤 格式化SD卡，Raspberry Pi Imager中选Erase选项 烧录目标系统 将装有操作系统的SD卡插入至树莓派 上电开机 有外接屏幕可以看到启动过程，没有则等待几分钟后ssh远程登陆树莓派查看 树莓派联网 1.外接网线 2.修改网卡配置，编辑文件cd /etc/netplan/50-cloud-init.ymal 123456789network: version: 2 wifis: wlan0: dhcp4: true optional: true access-points: wifi名称: # 名称有空格时，用双引号 password: &quot;wifi密码&quot; 使文件生效 12netplan generatenetplan apply Ping一下网址看是否连通 手动安装下net-tools: apt-get install net-tools，使用命令ifconfig -a查看本机IPssh连接树莓派 遇到问题1.ssh连接报错1234567@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.... 解决：清理之前保存的认证密钥 1234// 查看ssh-keygen -l -f ~/.ssh/known_hosts// 清理192.169.1.1的认证rsassh-keygen -R 192.169.1.1 使用sshkey连接树莓派 本地电脑上生成sshkey 将公钥复制到树莓派上 cat ~/.ssh/pi_rsa.pub | ssh &lt;USERNAME&gt;@&lt;IP-ADDRESS&gt; 'cat &gt;&gt; .ssh/authorized_keys’ 本地电脑用sshkey连接树莓派 ssh -i ~/.ssh/pi_rsa &lt;USERNAME&gt;@&lt;IP-ADDRESS&gt;","link":"/2020/06/18/rasp-os/"},{"title":"树莓派Pico的小应用","text":"开始的设想pico出来一段时间了，这个只要4刀的小开发板被各硬件营销号捧得很高。本来不以为意，但在肝动森的某个下午，看到家门口的邮箱mail_box突然觉得很可爱，就想看看能不能用pico实现一个成品版。想当然的认为只要有wifi模块+步进电机模块就能搞定。于是，开始了pico的学习。 开机 按住板上的BOOTSEL键，连接micro usb至电脑 从官网上下载适合pico用的micropython固件，拖至pico中，上传完毕后pico会自动从电脑弹出 再将pico直接连接至电脑，不用按BOOTSEL键 使用Thonny在pico中编程，Thonny会自动识别pico解释器，详见Thonny窗口：工具-设置-解释器 查看系统中的包 12import oshelp(“modules”) 点亮Pico上的LED12345678910111213141516import osfrom machine import Pinimport time# LED灯的pin脚l=Pin(25,Pin.OUT)# 常亮# l.high()# 闪烁while True: l.value(1) time.sleep(1) l.value(0) time.sleep(1) 将Pico联网准备硬件： 面包版 公母跳线 Wifi模块 WSP01 步骤： 先将下列依赖代码上传至pico，命名wifiat.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import utimeclass at(object): def __init__(self,uart): self.uart=uart def sendCMD_waitResp(self,cmd, timeout=2000): print(&quot;CMD: &quot; + cmd) self.uart.write(cmd.encode('utf-8')) return self.waitResp(timeout) def waitResp(self,timeout=2000): prvMills = utime.ticks_ms() resp = b&quot;&quot; while (utime.ticks_ms()-prvMills)&lt;timeout: if self.uart.any(): resp = b&quot;&quot;.join([resp, self.uart.read(1)]) print(resp) return resp def sendCMD_waitRespLine(self,cmd, timeout=2000): print(&quot;CMD: &quot; + cmd) self.uart.write(cmd.encode('utf-8')) return self.waitRespLine(timeout) def waitRespLine(self,timeout=2000): cl=[] prvMills = utime.ticks_ms() while (utime.ticks_ms()-prvMills)&lt;timeout: if self.uart.any(): li=self.uart.readline() print(li) cl.append(li) return cl def restart(self): self.sendCMD_waitResp('+++') return self.sendCMD_waitResp(&quot;AT+RST\\r\\n&quot;) def connect(self,name,password): self.sendCMD_waitResp('AT+CWMODE=1\\r\\n') cmd='AT+CWJAP=&quot;%s&quot;,&quot;%s&quot;\\r\\n' % (name,password) return self.sendCMD_waitResp(cmd) def netinfo(self): return self.sendCMD_waitResp(&quot;AT+CIFSR\\r\\n&quot;) def info(self): return self.sendCMD_waitResp(&quot;AT+GMR\\r\\n&quot;) def restore(self): return self.sendCMD_waitResp(&quot;AT+RESTORE\\r\\n&quot;) def ping(self,doip): return self.sendCMD_waitResp('AT+PING=&quot;%s&quot;\\r\\n' % (doip,)) def disconnect(self): return self.sendCMD_waitResp(&quot;AT+CWQAP\\r\\n&quot;) def http(self,url,method=&quot;GET&quot;,ua=1,content=1,data='',timeout=6): self.sendCMD_waitResp(&quot;+++&quot;) typ,edx,domain,rel=url.split(&quot;/&quot;,3) if &quot;HTTP&quot; == typ[0:-1].upper(): cs='AT+CIPSTART=&quot;TCP&quot;,&quot;%s&quot;,80\\r\\n' % (domain,) else: self.sendCMD_waitResp(&quot;AT+CIPSSLSIZE=4096\\r\\n&quot;) cs='AT+CIPSTART=&quot;SSL&quot;,&quot;%s&quot;,443\\r\\n' % (domain,) self.sendCMD_waitResp(cs) self.sendCMD_waitResp('AT+CIPMODE=1\\r\\n') self.sendCMD_waitResp('AT+CIPSEND\\r\\n') if ua==1: ua=&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1&quot; elif ua==2: ua=&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&quot; elif ua==3: ua=&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&quot; elif ua==4: ua=&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&quot; if content==1: content=&quot;text/html;charset=utf-8&quot; elif content==2: content=&quot;text/xml&quot; elif content==3: content=&quot;application/json&quot; elif content==4: content=&quot;multipart/form-data&quot; elif content==5: content=&quot;application/x-www-form-urlencoded&quot; c=&quot;%s %s HTTP/1.1\\r\\nHOST:%s \\r\\nContent-Type: %s\\r\\nUser-Agent:%s \\r\\n \\n %s \\r\\n\\r\\n &quot; % (method,url,domain,content,ua,data) return self.sendCMD_waitRespLine(c,1000*timeout) 连接pico与esp01 连接电脑，此时esp01的红色led灯会常亮 在Thonny的shell中输入代码 123456789101112131415# 固件模块from machine import UART# 导入依赖wifiat.pyfrom wifiat import atuart=UART(0,115200)AT=at(uart)# 连接wifiAT.connect(“Wi-Fi名”,”Wi-Fi密码”)# 查看信息AT.info()# 查看联网信息AT.netinfo() 查看联网信息AT.netinfo()如下显示则连接成功 1234CMD: AT+CIFSRb'WIFI CONNECTED\\r\\nWIFI GOT IP\\r\\n\\r\\nOAT+CIFSR\\r\\r\\n+CIFSR:STAIP,&quot;192.168.3.32&quot;\\r\\n+CIFSR:STAMAC,&quot;e8:db:84:95:94:33&quot;\\r\\n\\r\\nOK\\r\\n'b'WIFI CONNECTED\\r\\nWIFI GOT IP\\r\\n\\r\\nOAT+CIFSR\\r\\r\\n+CIFSR:STAIP,&quot;192.168.3.32&quot;\\r\\n+CIFSR:STAMAC,&quot;e8:db:84:95:94:33&quot;\\r\\n\\r\\nOK\\r\\n' GET请求 123resp=AT.http(“http://网址/get”)AT.http(&quot;http://httpbin.org/get&quot;) POST请求 12resp=AT.http(“http://网址/post”,mothod=“POST”,data='数据')AT.http(&quot;http://httpbin.org/post&quot;,method=&quot;POST&quot;,data='{&quot;a&quot;:1,&quot;b&quot;:2}') resp可返回响应列表 参考：邪恶的胖次菌","link":"/2021/03/11/pico-toy/"}],"tags":[{"name":"server","slug":"server","link":"/tags/server/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"cron","slug":"cron","link":"/tags/cron/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"config","slug":"config","link":"/tags/config/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"bash_profile","slug":"bash-profile","link":"/tags/bash-profile/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"wechat","slug":"wechat","link":"/tags/wechat/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"arduino","slug":"arduino","link":"/tags/arduino/"},{"name":"version","slug":"version","link":"/tags/version/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"Rasperry Pi","slug":"Rasperry-Pi","link":"/tags/Rasperry-Pi/"},{"name":"pico","slug":"pico","link":"/tags/pico/"}],"categories":[{"name":"config","slug":"config","link":"/categories/config/"},{"name":"note","slug":"note","link":"/categories/note/"}]}